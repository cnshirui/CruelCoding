<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>残酷刷题群</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            margin: 20px;
            color: #333;
        }
        h1 {
            text-align: center;
        }
        #loading {
            text-align: center;
            font-size: 1.2em;
            margin-top: 20px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            font-size: 14px;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: center; /* Center align for better look with subheaders */
        }
        /* Using a clear font for distinguishing l and I */
        .clear-font {
            font-family: "JetBrains Mono", "Cascadia Code", "Source Code Pro", Menlo, Monaco, Consolas, "Courier New", monospace;
            text-align: left; /* Keep left align for text fields */
        }
        td:nth-child(1) {
             text-align: center; /* Rank center */
        }
        th {
            background-color: #f2f2f2;
            cursor: pointer;
            user-select: none;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        /* Adjust sticky positioning for two-row header if needed, 
           but simple sticky top:0 works if rows are grouped in thead. 
           However, the second row needs top offset if we want both visible on scroll.
           For simplicity, let's keep basic sticky or just sticky the whole thead.
           Note: distinct top values needed for stacked sticky rows.
        */
        thead tr:nth-child(1) th {
            top: 0;
        }
        thead tr:nth-child(2) th {
            top: 38px; /* Approx height of first row */
             z-index: 9;
        }

        th:hover {
            background-color: #ddd;
        }
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        tr:hover {
            background-color: #f1f1f1;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
</head>
<body>

    <h1>残酷刷题群</h1>

    <div id="loading">Loading data...</div>

    <div style="text-align: center; margin-bottom: 10px;">
        <button id="loadMoreBtn" onclick="loadMoreWeeks()" style="padding: 10px 20px; font-size: 16px; cursor: pointer; display: none;">Load More Weeks</button>
    </div>

    <table id="scoreTable" style="display:none;">
        <thead id="tableHead">
            <!-- Headers will be generated dynamically -->
        </thead>
        <tbody id="tableBody">
        </tbody>
    </table>

    <script>
        const URLs = {
            excel: 'https://raw.githubusercontent.com/wisdompeak/lc-score-board/refs/heads/gh-pages/generateEXCEL/index.xlsx',
            cruelId: 'https://raw.githubusercontent.com/wisdompeak/lc-score-board/refs/heads/gh-pages/getRank/id.in',
            cruelDate: 'https://raw.githubusercontent.com/wisdompeak/lc-score-board/refs/heads/gh-pages/generateEXCEL/Data/Members/In.txt'
        };

        let tableData = [];
        let contestMeta = []; 
        let visibleWeeks = 3;

        async function fetchData() {
            try {
                const [excelParams, idParams, dateParams] = await Promise.all([
                    fetch(URLs.excel).then(res => res.arrayBuffer()),
                    fetch(URLs.cruelId).then(res => res.text()),
                    fetch(URLs.cruelDate).then(res => res.text())
                ]);

                const idMap = new Map();
                const idLines = idParams.split('\n');
                idLines.forEach((line, index) => {
                    const name = line.trim();
                    if (name) {
                        idMap.set(name, index + 1);
                    }
                });

                const dateMap = new Map();
                const dateLines = dateParams.split('\n');
                dateLines.forEach(line => {
                    const parts = line.trim().split(/\s+/);
                    if (parts.length >= 2) {
                        const name = parts[0];
                        const dateStr = parts[1];
                        
                        let formattedDate = dateStr;
                        if (dateStr.includes('/')) {
                            const [m, d, y] = dateStr.split('/');
                            if (m && d && y) {
                                formattedDate = `${y}-${m.padStart(2, '0')}-${d.padStart(2, '0')}`;
                            }
                        }
                        dateMap.set(name, formattedDate);
                    }
                });

                const workbook = XLSX.read(excelParams, { type: 'array' });
                const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                const rawData = XLSX.utils.sheet_to_json(firstSheet, { header: 1 });

                // Dynamically find the "Contest" row
                let contestRowIndex = -1;
                for (let i = 0; i < rawData.length; i++) {
                    if (rawData[i] && rawData[i][1] === 'Contest') {
                        contestRowIndex = i;
                        break;
                    }
                }

                if (contestRowIndex === -1) {
                    throw new Error("Could not find 'Contest' header row in Excel.");
                }

                contestMeta = [];
                const headerRow = rawData[contestRowIndex];
                for (let i = 5; i < headerRow.length; i++) {
                    const cell = headerRow[i];
                    // Check if cell is a number (Contest ID)
                    if (cell && !isNaN(cell)) {
                        contestMeta.push({
                            id: cell,
                            rankIndex: i,
                            scoreIndex: i + 1
                        });
                    }
                }

                let dataStartIndex = -1;
                for (let i = 0; i < rawData.length; i++) {
                    if (rawData[i][0] == 1) {
                        dataStartIndex = i;
                        break;
                    }
                }

                if (dataStartIndex === -1) dataStartIndex = 11;

                const processedData = [];
                const footerKeywords = [
                    "-1:", "-2:", "BG Color:", "Full list", "Recommended resources", 
                    "See where we are", "Cruel System Design", "If you are interested", 
                    "Make sure you agree", "[Blacklisted", "Graduated members"
                ];
                
                for (let i = dataStartIndex; i < rawData.length; i++) {
                    const row = rawData[i];
                    if (!row || row.length < 2) continue;

                    const rank = row[0];
                    const username = row[1] ? String(row[1]).trim() : '';
                    
                    if (!username || !rank) continue;

                    if (footerKeywords.some(key => username.includes(key))) {
                        break;
                    }

                    const days = row[2];
                    const rating = row[3];
                    const score = row[4];

                    const cruelId = idMap.get(username) || ''; 
                    const cruelDate = dateMap.get(username) || '';

                    // Capture contest results
                    const contests = {};
                    contestMeta.forEach(meta => {
                        contests[meta.id] = {
                            rank: row[meta.rankIndex],
                            score: row[meta.scoreIndex]
                        };
                    });

                    processedData.push({
                        rank: rank,
                        cruelId: cruelId,
                        cruelDate: cruelDate,
                        username: username,
                        days: days,
                        rating: rating,
                        score: score,
                        contests: contests
                    });
                }

                tableData = processedData;
                renderTableHeaders();
                renderTable(tableData);

                document.getElementById('loading').style.display = 'none';
                document.getElementById('scoreTable').style.display = 'table';
                document.getElementById('loadMoreBtn').style.display = 'inline-block';

            } catch (error) {
                console.error("Error fetching or processing data:", error);
                document.getElementById('loading').textContent = "Error loading data. Check console for details.";
            }
        }

        function renderTableHeaders() {
            const thead = document.getElementById('tableHead');
            thead.innerHTML = '';
            
            const tr1 = document.createElement('tr');
            const tr2 = document.createElement('tr');

            const staticHeaders = [
                { text: 'Rank', key: 'rank' },
                { text: 'CruelID', key: 'cruelId' },
                { text: 'CruelDate', key: 'cruelDate' },
                { text: 'Username', key: 'username' },
                { text: 'Days', key: 'days' },
                { text: 'Rating', key: 'rating' },
                { text: 'Score', key: 'score' }
            ];

            staticHeaders.forEach(h => {
                const th = document.createElement('th');
                th.innerText = h.text;
                th.rowSpan = 2;
                th.onclick = () => sortTable(h.key);
                tr1.appendChild(th);
            });

            // Dynamic Contest Headers
            const weeksToShow = contestMeta.slice(0, visibleWeeks);
            weeksToShow.forEach(meta => {
                // Top Row: Contest Name
                const thTop = document.createElement('th');
                thTop.innerText = meta.id; 
                thTop.colSpan = 2;
                thTop.style.textAlign = 'center';
                tr1.appendChild(thTop);

                // Bottom Row: Rank and Score
                const thRank = document.createElement('th');
                thRank.innerText = 'Rank';
                thRank.onclick = () => sortTable('contest_' + meta.id + '_rank');
                tr2.appendChild(thRank);

                const thScore = document.createElement('th');
                thScore.innerText = 'Score';
                thScore.onclick = () => sortTable('contest_' + meta.id + '_score');
                tr2.appendChild(thScore);
            });

            thead.appendChild(tr1);
            thead.appendChild(tr2);
        }

        function renderTable(data) {
            const tbody = document.getElementById('tableBody');
            tbody.innerHTML = '';
            
            const weeksToShow = contestMeta.slice(0, visibleWeeks);

            data.forEach(row => {
                const tr = document.createElement('tr');
                
                let html = `
                    <td>${row.rank || ''}</td>
                    <td class="clear-font">${row.cruelId || ''}</td>
                    <td class="clear-font">${row.cruelDate || ''}</td>
                    <td class="clear-font">${row.username || ''}</td>
                    <td>${row.days || ''}</td>
                    <td>${row.rating || ''}</td>
                    <td>${row.score || ''}</td>
                `;

                weeksToShow.forEach(meta => {
                    const cData = row.contests[meta.id] || {};
                    html += `<td>${cData.rank !== undefined ? cData.rank : ''}</td>`;
                    html += `<td>${cData.score !== undefined ? cData.score : ''}</td>`;
                });

                tr.innerHTML = html;
                tbody.appendChild(tr);
            });
        }

        function loadMoreWeeks() {
            visibleWeeks += 3;
            renderTableHeaders();
            renderTable(tableData);
        }

        let sortDirection = {};

        function sortTable(key) {
            
            if (!sortDirection[key]) sortDirection[key] = 'asc';
            else sortDirection[key] = sortDirection[key] === 'asc' ? 'desc' : 'asc';

            const dir = sortDirection[key];

            tableData.sort((a, b) => {
                let valA, valB;

                if (key.startsWith('contest_')) {
                    const parts = key.split('_');
                    const contestId = parts[1];
                    const type = parts[2]; // 'rank' or 'score'
                    valA = a.contests[contestId] ? a.contests[contestId][type] : null;
                    valB = b.contests[contestId] ? b.contests[contestId][type] : null;
                } else {
                    valA = a[key];
                    valB = b[key];
                }

                // Handle empty values (push to bottom usually, or top)
                // Let's treat null/empty as -Infinity or Infinity depending on what we want.
                // Or just standard comparison.
                
                // Helper to get number
                const getNum = (v) => {
                    if (v === undefined || v === null || v === '') return -999999; // Treat empty as very small
                    const n = parseFloat(v);
                    return isNaN(n) ? v : n;
                };

                let nA = getNum(valA);
                let nB = getNum(valB);

                const isNumeric = typeof nA === 'number' && typeof nB === 'number';

                if (!isNumeric) {
                     // String comparison
                    nA = String(valA || '').toLowerCase();
                    nB = String(valB || '').toLowerCase();
                }

                if (nA < nB) return dir === 'asc' ? -1 : 1;
                if (nA > nB) return dir === 'asc' ? 1 : -1;
                return 0;
            });

            renderTable(tableData);
        }

        fetchData();
    </script>
</body>
</html>