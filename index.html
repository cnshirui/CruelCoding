<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>残酷刷题群</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            margin: 20px;
            color: #333;
        }
        h1 {
            text-align: center;
        }
        
        /* Tab Styles */
        .tab-container {
            text-align: left;
            margin-bottom: 20px;
            margin-left: 0;
        }
        .tab-button {
            padding: 5px 15px;
            font-size: 14px;
            cursor: pointer;
            background-color: #f1f1f1;
            border: 1px solid #ccc;
            border-bottom: none;
            outline: none;
            border-radius: 5px 5px 0 0;
            margin: 0 5px;
        }
        .tab-button.active {
            background-color: #fff;
            border-bottom: 2px solid white; /* Hide the border below */
            font-weight: bold;
            position: relative;
            top: 1px; /* Overlap border */
        }
        .tab-content {
            display: none;
            border-top: 1px solid #ccc;
            padding-top: 5px;
        }
        .tab-content.active {
            display: block;
        }

        #loading {
            text-align: center;
            font-size: 1.2em;
            margin-top: 20px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 5px;
            font-size: 14px;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 2px 4px;
            text-align: center; /* Center align for better look with subheaders */
            white-space: nowrap;
            width: 0.1%;
        }
        /* Using a clear font for distinguishing l and I */
        .clear-font {
            font-family: "JetBrains Mono", "Cascadia Code", "Source Code Pro", Menlo, Monaco, Consolas, "Courier New", monospace;
            text-align: left; /* Keep left align for text fields */
        }
        .georgia-font {
            font-family: Georgia, serif;
        }
        td:nth-child(1) {
             text-align: center; /* Rank center */
        }
        th {
            background-color: #f2f2f2;
            cursor: pointer;
            user-select: none;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        /* Adjust sticky positioning for two-row header if needed, 
           but simple sticky top:0 works if rows are grouped in thead. 
           However, the second row needs top offset if we want both visible on scroll.
           For simplicity, let's keep basic sticky or just sticky the whole thead.
           Note: distinct top values needed for stacked sticky rows.
        */
        thead tr:nth-child(1) th {
            top: 0;
        }
        thead tr:nth-child(2) th {
            top: 38px; /* Approx height of first row */
             z-index: 9;
        }

        th:hover {
            background-color: #ddd;
        }
        th.sort-asc::after {
            content: " ▲";
            font-size: 0.8em;
        }
        th.sort-desc::after {
            content: " ▼";
            font-size: 0.8em;
        }
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        tr:hover {
            background-color: #f1f1f1;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/exceljs/4.3.0/exceljs.min.js"></script>
</head>
<body>

    <div class="tab-container">
        <button class="tab-button active" onclick="openTab('scoreboard')">残酷排行榜</button>
        <button class="tab-button" onclick="openTab('daily')">每日打卡</button>
    </div>

    <!-- Tab 1: Scoreboard -->
    <div id="scoreboard" class="tab-content active">
        <div id="loading">Loading data...</div>

        <div style="text-align: left; margin-top: 10px; margin-bottom: 2px;">
            <button id="loadMoreBtn" onclick="loadMoreWeeks()" style="padding: 5px 15px; font-size: 14px; cursor: pointer; display: none;">Load More Weeks</button>
        </div>

        <div style="overflow-x: auto;">
            <table id="scoreTable" style="display:none; width: auto;">
                <thead id="tableHead">
                    <!-- Headers will be generated dynamically -->
                </thead>
                <tbody id="tableBody">
                </tbody>
            </table>
        </div>
    </div>

    <!-- Tab 2: Daily Check-in -->
    <div id="daily" class="tab-content">
        <div style="overflow-x: auto;">
            <table id="dailyTable" style="width: auto;">
                <thead>
                    <tr>
                        <th onclick="sortDailyTable('sortDate')" data-key="sortDate">Date</th>
                        <th onclick="sortDailyTable('id')" data-key="id">ID</th>
                        <th onclick="sortDailyTable('title')" data-key="title">Question</th>
                        <th onclick="sortDailyTable('tags')" data-key="tags">Tags</th>
                        <th onclick="sortDailyTable('level')" data-key="level">Level</th>
                        <th onclick="sortDailyTable('difficulty')" data-key="difficulty">Difficulty</th>
                        <th onclick="sortDailyTable('ytHtml')" data-key="ytHtml">YouTube</th>
                    </tr>
                </thead>
                <tbody id="dailyTableBody">
                </tbody>
            </table>
        </div>
    </div>

    <script>
        function openTab(tabName) {
            const tabs = document.getElementsByClassName("tab-content");
            for (let i = 0; i < tabs.length; i++) {
                tabs[i].classList.remove("active");
            }
            const buttons = document.getElementsByClassName("tab-button");
            for (let i = 0; i < buttons.length; i++) {
                buttons[i].classList.remove("active");
            }
            
            document.getElementById(tabName).classList.add("active");
            // Find the button that calls this function with this tabName? 
            // Simplified: we can just check innerText or use event.currentTarget if we passed event.
            // Let's just loop and match based on index or onclick attr.
            // Easiest is to pass 'event' to openTab(event, 'tabName') but we only changed HTML structure.
            // Let's fix button active state simply by matching text or order.
            // Or better, let's just make the buttons queryable.
            
            // Hardcoded for these two buttons for now
            if (tabName === 'scoreboard') {
                buttons[0].classList.add("active");
            } else {
                buttons[1].classList.add("active");
            }
        }

        const URLs = {
            excel: 'https://raw.githubusercontent.com/wisdompeak/lc-score-board/refs/heads/gh-pages/generateEXCEL/index.xlsx',
            cruelId: 'https://raw.githubusercontent.com/wisdompeak/lc-score-board/refs/heads/gh-pages/getRank/id.in',
            cruelDate: 'https://raw.githubusercontent.com/wisdompeak/lc-score-board/refs/heads/gh-pages/generateEXCEL/Data/Members/In.txt',
            dailyCsv: 'https://corsproxy.io/?' + encodeURIComponent('https://docs.google.com/spreadsheets/d/1kBGyRsSdbGDu7DzjQcC-UkZjZERdrP8-_QyVGXHSrB8/export?format=csv&gid=0'),
            leetcodeJson: 'https://raw.githubusercontent.com/cnshirui/CruelCoding/refs/heads/main/leetcode_questions.json'
        };

        let tableData = [];
        let contestMeta = []; 
        let visibleWeeks = 3;
        let currentSort = { key: null, dir: null };
        let dailyDataLoaded = false;
        let leetcodeMap = null;

        // Daily Tab Globals
        let dailyTableData = [];
        let dailySort = { key: 'sortDate', dir: 'desc' };

        function openTab(tabName) {
            const tabs = document.getElementsByClassName("tab-content");
            for (let i = 0; i < tabs.length; i++) {
                tabs[i].classList.remove("active");
            }
            const buttons = document.getElementsByClassName("tab-button");
            for (let i = 0; i < buttons.length; i++) {
                buttons[i].classList.remove("active");
            }
            
            document.getElementById(tabName).classList.add("active");
            
            if (tabName === 'scoreboard') {
                buttons[0].classList.add("active");
            } else {
                buttons[1].classList.add("active");
                if (!dailyDataLoaded) {
                    fetchDailyData();
                }
            }
        }

        async function fetchDailyData() {
            const tbody = document.getElementById('dailyTableBody');
            tbody.innerHTML = '<tr><td colspan="7">Loading daily challenges...</td></tr>';

            try {
                // Fetch LeetCode JSON if not already
                if (!leetcodeMap) {
                    const res = await fetch(URLs.leetcodeJson);
                    if (!res.ok) throw new Error("Failed to fetch leetcode questions");
                    const questions = await res.json();
                    leetcodeMap = new Map();
                    questions.forEach(q => {
                        // Map using frontendId (string) and id (int) just in case
                        leetcodeMap.set(String(q.questionFrontendId), q);
                        leetcodeMap.set(String(q.id), q);
                    });
                }

                // Fetch CSV
                const csvRes = await fetch(URLs.dailyCsv);
                if (!csvRes.ok) throw new Error("Failed to fetch daily CSV");
                const csvText = await csvRes.text();

                const workbook = XLSX.read(csvText, { type: 'string' });
                const worksheet = workbook.Sheets[workbook.SheetNames[0]];
                const rawData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });

                const processedRows = [];
                
                rawData.forEach((row, index) => {
                    // Row is array. Date is Col C (index 2), ID is Col A (index 0)
                    if (!row || row.length < 3) return;
                    
                    let idRaw = row[0];
                    if (idRaw === undefined || idRaw === null || idRaw === '') return;
                    
                    let dateVal = row[2];
                    if (!dateVal) return;

                    // Clean ID (e.g., "527*" -> "527")
                    let id = String(idRaw).replace('*', '').trim();
                    if (isNaN(parseInt(id))) return; // Skip headers or non-numeric IDs

                    // Check if it's a valid date
                    let formattedDate = String(dateVal).trim();
                    if (formattedDate.toLowerCase() === 'date') return;

                    let sortDate = 0;
                    if (formattedDate.includes('/')) {
                        const parts = formattedDate.split('/');
                        if (parts.length === 3) {
                            let [m, d, y] = parts;
                            y = y.length === 2 ? '20' + y : y;
                            formattedDate = `${y}-${m.padStart(2, '0')}-${d.padStart(2, '0')}`;
                            sortDate = new Date(formattedDate).getTime();
                        }
                    } else if (!isNaN(formattedDate) && formattedDate.length >= 5) {
                        // Handle Excel serial date (e.g., 46037)
                        const serial = parseFloat(formattedDate);
                        const d = new Date(Math.round((serial - 25569) * 86400 * 1000));
                        if (!isNaN(d.getTime())) {
                            sortDate = d.getTime();
                            const year = d.getFullYear();
                            const month = String(d.getMonth() + 1).padStart(2, '0');
                            const day = String(d.getDate()).padStart(2, '0');
                            formattedDate = `${year}-${month}-${day}`;
                        }
                    } else {
                        // Try native parser
                        const d = new Date(formattedDate);
                        if (!isNaN(d.getTime())) {
                            sortDate = d.getTime();
                            const year = d.getFullYear();
                            const month = String(d.getMonth() + 1).padStart(2, '0');
                            const day = String(d.getDate()).padStart(2, '0');
                            formattedDate = `${year}-${month}-${day}`;
                        }
                    }
                    
                    if (isNaN(sortDate) || sortDate === 0) return;

                    const qInfo = leetcodeMap.get(String(id));
                    
                    let title = row[1];
                    let titleSlug = '';
                    let tags = [];
                    let level = row[5] || '';
                    let difficulty = row[6] || '';
                    
                    // Always read tags from spreadsheet
                    const t1 = row[3];
                    const t2 = row[4];
                    if (t1) tags.push(t1);
                    if (t2) tags.push(t2);

                    if (qInfo) {
                        title = qInfo.title;
                        titleSlug = qInfo.titleSlug;
                        if (!level) level = qInfo.difficulty;
                    } 

                    const youtube = row[7];
                    
                    // Truncate title
                    let displayTitle = title;
                    if (displayTitle && displayTitle.length > 50) {
                        displayTitle = displayTitle.substring(0, 50) + '...';
                    }

                    const link = titleSlug ? `https://leetcode.com/problems/${titleSlug}` : '#';
                    const titleHtml = titleSlug ? `<a href="${link}" target="_blank">${displayTitle}</a>` : displayTitle;

                    // Youtube Link
                    const ytHtml = youtube && youtube !== '-' ? `<a href="${youtube}" target="_blank">Watch</a>` : '';

                    processedRows.push({
                        date: formattedDate,
                        sortDate: sortDate,
                        id: parseInt(id), // store as number for sorting
                        title: title || '', // raw title for sorting
                        titleHtml: titleHtml,
                        tags: tags.join(', '),
                        level: level,
                        difficulty: difficulty ? parseFloat(difficulty) : 0, // numeric for sort
                        ytHtml: ytHtml
                    });
                });

                dailyTableData = processedRows;
                // Initial Sort
                sortDailyTable('sortDate', true); // true = force default or just apply sort
                dailyDataLoaded = true;

            } catch (error) {
                console.error("Error loading daily data:", error);
                tbody.innerHTML = `<tr><td colspan="7" style="color: red;">Error loading data: ${error.message}</td></tr>`;
            }
        }

        function sortDailyTable(key, initial = false) {
            if (!initial) {
                if (dailySort.key === key) {
                    dailySort.dir = dailySort.dir === 'asc' ? 'desc' : 'asc';
                } else {
                    dailySort.key = key;
                    dailySort.dir = 'asc'; // Default asc for new column, except maybe date?
                    if (key === 'sortDate') dailySort.dir = 'desc'; // Date default desc
                }
            }

            const dir = dailySort.dir;
            
            dailyTableData.sort((a, b) => {
                let valA = a[key];
                let valB = b[key];
                
                if (valA === undefined || valA === null) valA = '';
                if (valB === undefined || valB === null) valB = '';

                if (typeof valA === 'string') valA = valA.toLowerCase();
                if (typeof valB === 'string') valB = valB.toLowerCase();

                if (valA < valB) return dir === 'asc' ? -1 : 1;
                if (valA > valB) return dir === 'asc' ? 1 : -1;
                return 0;
            });

            renderDailyTable();
            updateDailyHeaders();
        }

        function renderDailyTable() {
            const tbody = document.getElementById('dailyTableBody');
            tbody.innerHTML = '';
            
            dailyTableData.forEach(row => {
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td>${row.date}</td>
                    <td>${row.id}</td>
                    <td class="clear-font" style="text-align: left;">${row.titleHtml}</td>
                    <td style="text-align: left;">${row.tags}</td>
                    <td>${row.level}</td>
                    <td>${row.difficulty || ''}</td>
                    <td>${row.ytHtml}</td>
                `;
                tbody.appendChild(tr);
            });
        }

        function updateDailyHeaders() {
            const headers = document.querySelectorAll('#dailyTable th');
            headers.forEach(th => {
                th.classList.remove('sort-asc', 'sort-desc');
                const key = th.getAttribute('data-key');
                if (key === dailySort.key) {
                    th.classList.add(dailySort.dir === 'asc' ? 'sort-asc' : 'sort-desc');
                }
            });
        }



        async function fetchData() {
            try {
                const [excelParams, idParams, dateParams] = await Promise.all([
                    fetch(URLs.excel).then(res => res.arrayBuffer()),
                    fetch(URLs.cruelId).then(res => res.text()),
                    fetch(URLs.cruelDate).then(res => res.text())
                ]);

                const idMap = new Map();
                const idLines = idParams.split('\n');
                idLines.forEach((line, index) => {
                    const name = line.trim();
                    if (name) {
                        idMap.set(name, index + 1);
                    }
                });

                const dateMap = new Map();
                const dateLines = dateParams.split('\n');
                dateLines.forEach(line => {
                    const parts = line.trim().split(/\s+/);
                    if (parts.length >= 2) {
                        const name = parts[0];
                        const dateStr = parts[1];
                        
                        let formattedDate = dateStr;
                        if (dateStr.includes('/')) {
                            const [m, d, y] = dateStr.split('/');
                            if (m && d && y) {
                                formattedDate = `${y}-${m.padStart(2, '0')}-${d.padStart(2, '0')}`;
                            }
                        }
                        dateMap.set(name, formattedDate);
                    }
                });

                const workbook = new ExcelJS.Workbook();
                await workbook.xlsx.load(excelParams);
                const worksheet = workbook.worksheets[0];
                
                let rawRows = [];
                worksheet.eachRow({ includeEmpty: true }, (row, rowNumber) => {
                    rawRows[rowNumber] = row;
                });

                // Dynamically find the "Contest" row
                let contestRowIndex = -1;
                for (let r = 1; r < rawRows.length; r++) {
                    const row = rawRows[r];
                    if (!row) continue;
                    // Column 2 is B
                    if (row.getCell(2).value === 'Contest') {
                        contestRowIndex = r;
                        break;
                    }
                }

                if (contestRowIndex === -1) {
                    throw new Error("Could not find 'Contest' header row in Excel.");
                }

                contestMeta = [];
                const headerRow = rawRows[contestRowIndex];
                let lastId = null;
                // Scan columns starting from F (6)
                // We'll scan a reasonable range, e.g., up to 200
                for (let c = 6; c <= 200; c++) {
                    const cell = headerRow.getCell(c);
                    const val = cell.value;
                    if (val && !isNaN(val) && val !== lastId) {
                        lastId = val;
                        contestMeta.push({
                            id: val,
                            rankCol: c,
                            scoreCol: c + 1
                        });
                    }
                }

                let dataStartIndex = -1;
                for (let r = 1; r < rawRows.length; r++) {
                    const row = rawRows[r];
                    if (row && row.getCell(1).value == 1) {
                        dataStartIndex = r;
                        break;
                    }
                }

                if (dataStartIndex === -1) dataStartIndex = 12;

                const processedData = [];
                const footerKeywords = [
                    "-1:", "-2:", "BG Color:", "Full list", "Recommended resources", 
                    "See where we are", "Cruel System Design", "If you are interested", 
                    "Make sure you agree", "[Blacklisted", "Graduated members",
                    "ranking-figure", "curve-figure"
                ];
                
                for (let r = dataStartIndex; r < rawRows.length; r++) {
                    const row = rawRows[r];
                    if (!row) continue;

                    const rank = row.getCell(1).value;
                    let username = row.getCell(2).value;
                    // Handle rich text or links if present, though usually just string
                    if (username && typeof username === 'object' && username.text) username = username.text;
                    username = username ? String(username).trim() : '';
                    
                    if (!username || !rank) continue;

                    if (footerKeywords.some(key => username.includes(key) || String(rank).includes(key))) {
                        break;
                    }

                    const days = row.getCell(3).value;
                    const rating = row.getCell(4).value;
                    const score = row.getCell(5).value;

                    const cruelId = idMap.get(username) || ''; 
                    const cruelDate = dateMap.get(username) || '';

                    // Capture contest results
                    const contests = {};
                    contestMeta.forEach(meta => {
                        const rankCell = row.getCell(meta.rankCol);
                        const scoreCell = row.getCell(meta.scoreCol);
                        
                        let rankVal = rankCell.value;
                        let scoreVal = scoreCell.value;
                        
                        // Extract Background Color
                        let bgColor = null;
                        if (rankCell.fill && rankCell.fill.type === 'pattern' && rankCell.fill.fgColor) {
                            // ExcelJS returns argb usually
                            const argb = rankCell.fill.fgColor.argb;
                            if (argb && argb.length >= 6) {
                                // Take last 6 chars for RGB
                                bgColor = '#' + argb.slice(argb.length - 6);
                            }
                        }

                        contests[meta.id] = {
                            rank: rankVal,
                            score: scoreVal,
                            bgColor: bgColor
                        };
                    });

                    processedData.push({
                        rank: rank,
                        cruelId: cruelId,
                        cruelDate: cruelDate,
                        username: username,
                        days: days,
                        rating: rating,
                        score: score,
                        contests: contests
                    });
                }

                tableData = processedData;
                renderTableHeaders();
                renderTable(tableData);

                document.getElementById('loading').style.display = 'none';
                document.getElementById('scoreTable').style.display = 'table';
                document.getElementById('loadMoreBtn').style.display = 'inline-block';

            } catch (error) {
                console.error("Error fetching or processing data:", error);
                document.getElementById('loading').textContent = "Error loading data. Check console for details.";
            }
        }

        function renderTableHeaders() {
            const thead = document.getElementById('tableHead');
            thead.innerHTML = '';
            
            const tr1 = document.createElement('tr');
            const tr2 = document.createElement('tr');

            const staticHeaders = [
                { text: 'Rank', key: 'rank' },
                { text: 'CruelID', key: 'cruelId' },
                { text: 'CruelDate', key: 'cruelDate' },
                { text: 'Username', key: 'username' },
                { text: 'Days', key: 'days' },
                { text: 'Rating', key: 'rating' },
                { text: 'Score', key: 'score' }
            ];

            staticHeaders.forEach(h => {
                const th = document.createElement('th');
                th.innerText = h.text;
                th.rowSpan = 2;
                if (h.key === 'cruelId') {
                    th.classList.add('georgia-font');
                }
                th.onclick = () => sortTable(h.key);
                if (currentSort.key === h.key) {
                    th.classList.add(currentSort.dir === 'asc' ? 'sort-asc' : 'sort-desc');
                }
                tr1.appendChild(th);
            });

            // Dynamic Contest Headers
            const weeksToShow = contestMeta.slice(0, visibleWeeks);
            weeksToShow.forEach(meta => {
                // Top Row: Contest Name
                const thTop = document.createElement('th');
                thTop.innerText = meta.id; 
                thTop.colSpan = 2;
                thTop.style.textAlign = 'center';
                tr1.appendChild(thTop);

                // Bottom Row: Rank and Score
                const thRank = document.createElement('th');
                thRank.innerText = 'Rank';
                const keyRank = 'contest_' + meta.id + '_rank';
                thRank.onclick = () => sortTable(keyRank);
                if (currentSort.key === keyRank) {
                    thRank.classList.add(currentSort.dir === 'asc' ? 'sort-asc' : 'sort-desc');
                }
                tr2.appendChild(thRank);

                const thScore = document.createElement('th');
                thScore.innerText = 'Score';
                const keyScore = 'contest_' + meta.id + '_score';
                thScore.onclick = () => sortTable(keyScore);
                if (currentSort.key === keyScore) {
                    thScore.classList.add(currentSort.dir === 'asc' ? 'sort-asc' : 'sort-desc');
                }
                tr2.appendChild(thScore);
            });

            thead.appendChild(tr1);
            thead.appendChild(tr2);
        }

        function renderTable(data) {
            const tbody = document.getElementById('tableBody');
            tbody.innerHTML = '';
            
            const weeksToShow = contestMeta.slice(0, visibleWeeks);

            data.forEach(row => {
                const tr = document.createElement('tr');
                
                let html = `
                    <td>${row.rank || ''}</td>
                    <td class="clear-font">${row.cruelId || ''}</td>
                    <td class="clear-font">${row.cruelDate || ''}</td>
                    <td class="clear-font">${row.username || ''}</td>
                    <td>${row.days ? row.days : ''}</td>
                    <td>${row.rating ? row.rating : ''}</td>
                    <td>${row.score ? (typeof row.score === 'number' ? row.score.toFixed(1) : row.score) : ''}</td>
                `;

                weeksToShow.forEach(meta => {
                    const cData = row.contests[meta.id] || {};
                    const score = cData.score !== undefined ? (typeof cData.score === 'number' ? cData.score.toFixed(1) : cData.score) : '';
                    const rank = cData.rank !== undefined ? cData.rank : '';
                    const bgColor = cData.bgColor;
                    
                    const styleAttr = bgColor ? `style="background-color: ${bgColor}; color: black;"` : '';
                    
                    html += `<td ${styleAttr}>${rank}</td>`;
                    html += `<td>${score}</td>`;
                });

                tr.innerHTML = html;
                tbody.appendChild(tr);
            });
        }

        function loadMoreWeeks() {
            visibleWeeks += 3;
            renderTableHeaders();
            renderTable(tableData);
        }

        function sortTable(key) {
            if (currentSort.key === key) {
                currentSort.dir = currentSort.dir === 'asc' ? 'desc' : 'asc';
            } else {
                currentSort.key = key;
                currentSort.dir = 'asc'; // Default to ascending first
            }

            const dir = currentSort.dir;

            tableData.sort((a, b) => {
                let valA, valB;

                if (key.startsWith('contest_')) {
                    const parts = key.split('_');
                    const contestId = parts[1];
                    const type = parts[2]; // 'rank' or 'score'
                    valA = a.contests[contestId] ? a.contests[contestId][type] : null;
                    valB = b.contests[contestId] ? b.contests[contestId][type] : null;
                } else {
                    valA = a[key];
                    valB = b[key];
                }

                // Helper to get number
                // We treat null/undefined/empty as a special "missing" value.
                // We also want to treat -1 as a special "missing" or "absent" value that always goes to the bottom.
                const getNum = (v) => {
                    if (v === undefined || v === null || v === '') return null; 
                    const n = parseFloat(v);
                    return isNaN(n) ? v : n;
                };

                let nA = getNum(valA);
                let nB = getNum(valB);

                // Check for "missing" values (null or -1)
                // If we want -1 to always be at the bottom:
                // In ASC sort: -1 should be > any valid number
                // In DESC sort: -1 should be < any valid number
                // Actually, "bottom" means last in the list.
                // So if ASC:  [1, 2, 3, -1] -> -1 is treated as Infinity
                // So if DESC: [3, 2, 1, -1] -> -1 is treated as -Infinity
                
                const isMissing = (v) => v === null || v === -1 || v === '-1';

                const missingA = isMissing(nA);
                const missingB = isMissing(nB);

                if (missingA && missingB) return 0;
                if (missingA) return 1; // A is missing, so A > B (to put A at end in asc), or A < B ??
                // Let's refine:
                // We want missing values to ALWAYS be at the end of the array.
                // Array.sort expects:
                // < 0 if a comes first
                // > 0 if b comes first
                
                // If we want them at the bottom, they should be "greater" than everything else in ASC
                // and "smaller" than everything else in DESC? No, that would put them at top in DESC.
                // To force them to the bottom, we manually check sort direction.
                
                if (missingA) return 1; // Put A after B
                if (missingB) return -1; // Put B after A

                // Normal comparison for non-missing values
                const isNumeric = typeof nA === 'number' && typeof nB === 'number';

                if (!isNumeric) {
                     // String comparison
                    nA = String(nA).toLowerCase();
                    nB = String(nB).toLowerCase();
                }

                if (nA < nB) return dir === 'asc' ? -1 : 1;
                if (nA > nB) return dir === 'asc' ? 1 : -1;
                return 0;
            });
            
            renderTableHeaders();
            renderTable(tableData);
        }

        fetchData();
    </script>
</body>
</html>