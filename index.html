<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>残酷刷题群</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            margin: 20px;
            color: #333;
        }
        h1 {
            text-align: center;
        }
        #loading {
            text-align: center;
            font-size: 1.2em;
            margin-top: 20px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            font-size: 14px;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 4px 8px;
            text-align: center; /* Center align for better look with subheaders */
            white-space: nowrap;
        }
        /* Using a clear font for distinguishing l and I */
        .clear-font {
            font-family: "JetBrains Mono", "Cascadia Code", "Source Code Pro", Menlo, Monaco, Consolas, "Courier New", monospace;
            text-align: left; /* Keep left align for text fields */
        }
        .georgia-font {
            font-family: Georgia, serif;
        }
        td:nth-child(1) {
             text-align: center; /* Rank center */
        }
        th {
            background-color: #f2f2f2;
            cursor: pointer;
            user-select: none;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        /* Adjust sticky positioning for two-row header if needed, 
           but simple sticky top:0 works if rows are grouped in thead. 
           However, the second row needs top offset if we want both visible on scroll.
           For simplicity, let's keep basic sticky or just sticky the whole thead.
           Note: distinct top values needed for stacked sticky rows.
        */
        thead tr:nth-child(1) th {
            top: 0;
        }
        thead tr:nth-child(2) th {
            top: 38px; /* Approx height of first row */
             z-index: 9;
        }

        th:hover {
            background-color: #ddd;
        }
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        tr:hover {
            background-color: #f1f1f1;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/exceljs/4.3.0/exceljs.min.js"></script>
</head>
<body>

    <h1>残酷刷题群</h1>

    <div id="loading">Loading data...</div>

    <div style="text-align: center; margin-bottom: 10px;">
        <button id="loadMoreBtn" onclick="loadMoreWeeks()" style="padding: 10px 20px; font-size: 16px; cursor: pointer; display: none;">Load More Weeks</button>
    </div>

    <div style="overflow-x: auto;">
        <table id="scoreTable" style="display:none; width: auto; min-width: 100%;">
            <thead id="tableHead">
                <!-- Headers will be generated dynamically -->
            </thead>
            <tbody id="tableBody">
            </tbody>
        </table>
    </div>

    <script>
        const URLs = {
            excel: 'https://raw.githubusercontent.com/wisdompeak/lc-score-board/refs/heads/gh-pages/generateEXCEL/index.xlsx',
            cruelId: 'https://raw.githubusercontent.com/wisdompeak/lc-score-board/refs/heads/gh-pages/getRank/id.in',
            cruelDate: 'https://raw.githubusercontent.com/wisdompeak/lc-score-board/refs/heads/gh-pages/generateEXCEL/Data/Members/In.txt'
        };

        let tableData = [];
        let contestMeta = []; 
        let visibleWeeks = 3;

        async function fetchData() {
            try {
                const [excelParams, idParams, dateParams] = await Promise.all([
                    fetch(URLs.excel).then(res => res.arrayBuffer()),
                    fetch(URLs.cruelId).then(res => res.text()),
                    fetch(URLs.cruelDate).then(res => res.text())
                ]);

                const idMap = new Map();
                const idLines = idParams.split('\n');
                idLines.forEach((line, index) => {
                    const name = line.trim();
                    if (name) {
                        idMap.set(name, index + 1);
                    }
                });

                const dateMap = new Map();
                const dateLines = dateParams.split('\n');
                dateLines.forEach(line => {
                    const parts = line.trim().split(/\s+/);
                    if (parts.length >= 2) {
                        const name = parts[0];
                        const dateStr = parts[1];
                        
                        let formattedDate = dateStr;
                        if (dateStr.includes('/')) {
                            const [m, d, y] = dateStr.split('/');
                            if (m && d && y) {
                                formattedDate = `${y}-${m.padStart(2, '0')}-${d.padStart(2, '0')}`;
                            }
                        }
                        dateMap.set(name, formattedDate);
                    }
                });

                const workbook = new ExcelJS.Workbook();
                await workbook.xlsx.load(excelParams);
                const worksheet = workbook.worksheets[0];
                
                let rawRows = [];
                worksheet.eachRow({ includeEmpty: true }, (row, rowNumber) => {
                    rawRows[rowNumber] = row;
                });

                // Dynamically find the "Contest" row
                let contestRowIndex = -1;
                for (let r = 1; r < rawRows.length; r++) {
                    const row = rawRows[r];
                    if (!row) continue;
                    // Column 2 is B
                    if (row.getCell(2).value === 'Contest') {
                        contestRowIndex = r;
                        break;
                    }
                }

                if (contestRowIndex === -1) {
                    throw new Error("Could not find 'Contest' header row in Excel.");
                }

                contestMeta = [];
                const headerRow = rawRows[contestRowIndex];
                let lastId = null;
                // Scan columns starting from F (6)
                // We'll scan a reasonable range, e.g., up to 200
                for (let c = 6; c <= 200; c++) {
                    const cell = headerRow.getCell(c);
                    const val = cell.value;
                    if (val && !isNaN(val) && val !== lastId) {
                        lastId = val;
                        contestMeta.push({
                            id: val,
                            rankCol: c,
                            scoreCol: c + 1
                        });
                    }
                }

                let dataStartIndex = -1;
                for (let r = 1; r < rawRows.length; r++) {
                    const row = rawRows[r];
                    if (row && row.getCell(1).value == 1) {
                        dataStartIndex = r;
                        break;
                    }
                }

                if (dataStartIndex === -1) dataStartIndex = 12;

                const processedData = [];
                const footerKeywords = [
                    "-1:", "-2:", "BG Color:", "Full list", "Recommended resources", 
                    "See where we are", "Cruel System Design", "If you are interested", 
                    "Make sure you agree", "[Blacklisted", "Graduated members",
                    "ranking-figure", "curve-figure"
                ];
                
                for (let r = dataStartIndex; r < rawRows.length; r++) {
                    const row = rawRows[r];
                    if (!row) continue;

                    const rank = row.getCell(1).value;
                    let username = row.getCell(2).value;
                    // Handle rich text or links if present, though usually just string
                    if (username && typeof username === 'object' && username.text) username = username.text;
                    username = username ? String(username).trim() : '';
                    
                    if (!username || !rank) continue;

                    if (footerKeywords.some(key => username.includes(key) || String(rank).includes(key))) {
                        break;
                    }

                    const days = row.getCell(3).value;
                    const rating = row.getCell(4).value;
                    const score = row.getCell(5).value;

                    const cruelId = idMap.get(username) || ''; 
                    const cruelDate = dateMap.get(username) || '';

                    // Capture contest results
                    const contests = {};
                    contestMeta.forEach(meta => {
                        const rankCell = row.getCell(meta.rankCol);
                        const scoreCell = row.getCell(meta.scoreCol);
                        
                        let rankVal = rankCell.value;
                        let scoreVal = scoreCell.value;
                        
                        // Extract Background Color
                        let bgColor = null;
                        if (rankCell.fill && rankCell.fill.type === 'pattern' && rankCell.fill.fgColor) {
                            // ExcelJS returns argb usually
                            const argb = rankCell.fill.fgColor.argb;
                            if (argb && argb.length >= 6) {
                                // Take last 6 chars for RGB
                                bgColor = '#' + argb.slice(argb.length - 6);
                            }
                        }

                        contests[meta.id] = {
                            rank: rankVal,
                            score: scoreVal,
                            bgColor: bgColor
                        };
                    });

                    processedData.push({
                        rank: rank,
                        cruelId: cruelId,
                        cruelDate: cruelDate,
                        username: username,
                        days: days,
                        rating: rating,
                        score: score,
                        contests: contests
                    });
                }

                tableData = processedData;
                renderTableHeaders();
                renderTable(tableData);

                document.getElementById('loading').style.display = 'none';
                document.getElementById('scoreTable').style.display = 'table';
                document.getElementById('loadMoreBtn').style.display = 'inline-block';

            } catch (error) {
                console.error("Error fetching or processing data:", error);
                document.getElementById('loading').textContent = "Error loading data. Check console for details.";
            }
        }

        function renderTableHeaders() {
            const thead = document.getElementById('tableHead');
            thead.innerHTML = '';
            
            const tr1 = document.createElement('tr');
            const tr2 = document.createElement('tr');

            const staticHeaders = [
                { text: 'Rank', key: 'rank' },
                { text: 'CruelID', key: 'cruelId' },
                { text: 'CruelDate', key: 'cruelDate' },
                { text: 'Username', key: 'username' },
                { text: 'Days', key: 'days' },
                { text: 'Rating', key: 'rating' },
                { text: 'Score', key: 'score' }
            ];

            staticHeaders.forEach(h => {
                const th = document.createElement('th');
                th.innerText = h.text;
                th.rowSpan = 2;
                if (h.key === 'cruelId') {
                    th.classList.add('georgia-font');
                }
                th.onclick = () => sortTable(h.key);
                tr1.appendChild(th);
            });

            // Dynamic Contest Headers
            const weeksToShow = contestMeta.slice(0, visibleWeeks);
            weeksToShow.forEach(meta => {
                // Top Row: Contest Name
                const thTop = document.createElement('th');
                thTop.innerText = meta.id; 
                thTop.colSpan = 2;
                thTop.style.textAlign = 'center';
                tr1.appendChild(thTop);

                // Bottom Row: Rank and Score
                const thRank = document.createElement('th');
                thRank.innerText = 'Rank';
                thRank.onclick = () => sortTable('contest_' + meta.id + '_rank');
                tr2.appendChild(thRank);

                const thScore = document.createElement('th');
                thScore.innerText = 'Score';
                thScore.onclick = () => sortTable('contest_' + meta.id + '_score');
                tr2.appendChild(thScore);
            });

            thead.appendChild(tr1);
            thead.appendChild(tr2);
        }

        function renderTable(data) {
            const tbody = document.getElementById('tableBody');
            tbody.innerHTML = '';
            
            const weeksToShow = contestMeta.slice(0, visibleWeeks);

            data.forEach(row => {
                const tr = document.createElement('tr');
                
                let html = `
                    <td>${row.rank || ''}</td>
                    <td class="clear-font">${row.cruelId || ''}</td>
                    <td class="clear-font">${row.cruelDate || ''}</td>
                    <td class="clear-font">${row.username || ''}</td>
                    <td>${row.days ? row.days : ''}</td>
                    <td>${row.rating ? row.rating : ''}</td>
                    <td>${row.score ? (typeof row.score === 'number' ? row.score.toFixed(1) : row.score) : ''}</td>
                `;

                weeksToShow.forEach(meta => {
                    const cData = row.contests[meta.id] || {};
                    const score = cData.score !== undefined ? (typeof cData.score === 'number' ? cData.score.toFixed(1) : cData.score) : '';
                    const rank = cData.rank !== undefined ? cData.rank : '';
                    const bgColor = cData.bgColor;
                    
                    const styleAttr = bgColor ? `style="background-color: ${bgColor}; color: black;"` : '';
                    
                    html += `<td ${styleAttr}>${rank}</td>`;
                    html += `<td>${score}</td>`;
                });

                tr.innerHTML = html;
                tbody.appendChild(tr);
            });
        }

        function loadMoreWeeks() {
            visibleWeeks += 3;
            renderTableHeaders();
            renderTable(tableData);
        }

        let sortDirection = {};

        function sortTable(key) {
            
            if (!sortDirection[key]) sortDirection[key] = 'asc';
            else sortDirection[key] = sortDirection[key] === 'asc' ? 'desc' : 'asc';

            const dir = sortDirection[key];

            tableData.sort((a, b) => {
                let valA, valB;

                if (key.startsWith('contest_')) {
                    const parts = key.split('_');
                    const contestId = parts[1];
                    const type = parts[2]; // 'rank' or 'score'
                    valA = a.contests[contestId] ? a.contests[contestId][type] : null;
                    valB = b.contests[contestId] ? b.contests[contestId][type] : null;
                } else {
                    valA = a[key];
                    valB = b[key];
                }

                // Handle empty values (push to bottom usually, or top)
                // Let's treat null/empty as -Infinity or Infinity depending on what we want.
                // Or just standard comparison.
                
                // Helper to get number
                const getNum = (v) => {
                    if (v === undefined || v === null || v === '') return -999999; // Treat empty as very small
                    const n = parseFloat(v);
                    return isNaN(n) ? v : n;
                };

                let nA = getNum(valA);
                let nB = getNum(valB);

                const isNumeric = typeof nA === 'number' && typeof nB === 'number';

                if (!isNumeric) {
                     // String comparison
                    nA = String(valA || '').toLowerCase();
                    nB = String(valB || '').toLowerCase();
                }

                if (nA < nB) return dir === 'asc' ? -1 : 1;
                if (nA > nB) return dir === 'asc' ? 1 : -1;
                return 0;
            });

            renderTable(tableData);
        }

        fetchData();
    </script>
</body>
</html>